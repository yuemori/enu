// This code was generated by a tool.
package enu

{{- if .ImportPkg}}
import {{.ImportPkg}}
{{end}}

type {{.Prefix}}Enumerable[{{.TypeWithConstraint}}] struct {
	enumerator Enumerator[{{.ItemType}}]
}

func New{{.Prefix}}[{{.TypeWithConstraint}}](e Enumerator[{{.ItemType}}]) *{{.Prefix}}Enumerable[{{.Type}}] {
	return &{{.Prefix}}Enumerable[{{.Type}}]{enumerator: e}
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) Each(iteratee func({{.ItemType}}, int)) {
	each[{{.ItemType}}](e, func(item {{.ItemType}}, index int) bool {
		iteratee(item, index)
		return true
	})
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) ToSlice() []{{.ItemType}} {
	return ToSlice[{{.ItemType}}](e)
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) Count() int {
	return Count[{{.ItemType}}](e)
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) Filter(predicate func({{.ItemType}}, int) bool) *{{.Prefix}}Enumerable[{{.Type}}] {
	return &{{.Prefix}}Enumerable[{{.Type}}]{
		enumerator: Filter[{{.ItemType}}](e, predicate),
	}
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) Nth(nth int) ({{.ItemType}}, bool) {
	return Nth[{{.ItemType}}](e, nth)
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) Find(predicate func({{.ItemType}}, int) bool) ({{.ItemType}}, bool) {
	return Find[{{.ItemType}}](e, predicate)
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) First() ({{.ItemType}}, bool) {
	return First[{{.ItemType}}](e)
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) Last() ({{.ItemType}}, bool) {
	return Last[{{.ItemType}}](e)
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) Reverse() *{{.Prefix}}Enumerable[{{.Type}}] {
	return &{{.Prefix}}Enumerable[{{.Type}}]{enumerator: Reverse[{{.ItemType}}](e)}
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) SortBy(sorter func(i, j {{.ItemType}}) bool) *{{.Prefix}}Enumerable[{{.Type}}] {
	return &{{.Prefix}}Enumerable[{{.Type}}]{enumerator: SortBy[{{.ItemType}}](e, sorter)}
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) Reject(predicate func({{.ItemType}}, int) bool) *{{.Prefix}}Enumerable[{{.Type}}] {
	return &{{.Prefix}}Enumerable[{{.Type}}]{enumerator: Reject[{{.ItemType}}](e, predicate)}
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) IsAll(predicate func({{.ItemType}}) bool) bool {
	return IsAll[{{.ItemType}}](e, predicate)
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) IsAny(predicate func({{.ItemType}}) bool) bool {
	return IsAny[{{.ItemType}}](e, predicate)
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) Take(num uint) *{{.Prefix}}Enumerable[{{.Type}}] {
	return &{{.Prefix}}Enumerable[{{.Type}}]{enumerator: Take[{{.ItemType}}](e, num)}
}

func (e *{{.Prefix}}Enumerable[{{.Type}}]) GetEnumerator() Enumerator[{{.ItemType}}] {
	return e.enumerator
}
{{ range $i, $e := .Extras -}}
{{ if or (eq $e "Uniq") (eq $e "Sort") }}
func (e *{{$.Prefix}}Enumerable[{{$.Type}}]) {{$e}}() *{{$.Prefix}}Enumerable[{{$.ItemType}}] {
	return New{{$.Prefix}}[{{$.Type}}]({{$e}}[{{$.ItemType}}](e))
}
{{end -}}
{{ if or (eq $e "Min") (eq $e "Max") (eq $e "Sum") }}
func (e *{{$.Prefix}}Enumerable[{{$.Type}}]) {{$e}}() {{$.ItemType}} {
	return {{$e}}[{{$.Type}}](e)
}
{{end -}}
{{ if eq $e "Contains" }}
func (e *{{$.Prefix}}Enumerable[{{$.Type}}]) Contains(item {{$.ItemType}}) bool {
	return Contains[{{$.ItemType}}](e, item)
}
{{end -}}
{{ if eq $e "IndexOf" }}
func (e *{{$.Prefix}}Enumerable[{{$.Type}}]) IndexOf(item {{$.ItemType}}) int {
	return IndexOf[{{$.ItemType}}](e, item)
}
{{end -}}
{{ if eq $e "ToMap" }}
func (e *{{$.Prefix}}Enumerable[{{$.Type}}]) ToMap() map[int]{{$.ItemType}} {
	return Reduce[{{$.ItemType}}](e, func(agg map[int]{{$.ItemType}}, item {{$.ItemType}}, index int) map[int]{{$.ItemType}} {
		agg[index] = item
		return agg
	}, map[int]{{$.ItemType}}{})
}
{{end -}}
{{end -}}
