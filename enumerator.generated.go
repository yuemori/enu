// This code was generated by a tool.
package enu

type Enumerator[T any] struct {
	iter   IEnumerable[T]
}

func New[T any](e IEnumerable[T]) *Enumerator[T] {
	return &Enumerator[T]{iter: e}
}

func (e *Enumerator[T]) Each(iteratee func(T, int)) {
	each(e.iter, func(item T, index int) bool {
		iteratee(item, index)
		return true
	})
}

func (e *Enumerator[T]) ToSlice() []T {
	return ToSlice(e.iter)
}

func (e *Enumerator[T]) Count() int {
	return Count(e.iter)
}

func (e *Enumerator[T]) Filter(predicate func(T, int) bool) *Enumerator[T] {
	return &Enumerator[T]{
		iter: Filter(e.iter, predicate),
	}
}

func (e *Enumerator[T]) Nth(nth int) (T, bool) {
	return Nth(e.iter, nth)
}

func (e *Enumerator[T]) Find(predicate func(T, int) bool) (T, bool) {
	return Find(e.iter, predicate)
}

func (e *Enumerator[T]) First() (T, bool) {
	return First(e.iter)
}

func (e *Enumerator[T]) Last() (T, bool) {
	return Last(e.iter)
}

func (e *Enumerator[T]) Reverse() *Enumerator[T] {
	return &Enumerator[T]{iter: Reverse(e.iter)}
}

func (e *Enumerator[T]) SortBy(sorter func(i, j T) bool) *Enumerator[T] {
	return &Enumerator[T]{iter: SortBy(e.iter, sorter)}
}

func (e *Enumerator[T]) Reject(predicate func(T, int) bool) *Enumerator[T] {
	return &Enumerator[T]{iter: Reject(e.iter, predicate)}
}

func (e *Enumerator[T]) IsAll(predicate func(T) bool) bool {
	return IsAll(e.iter, predicate)
}

func (e *Enumerator[T]) IsAny(predicate func(T) bool) bool {
	return IsAny(e.iter, predicate)
}

func (e *Enumerator[T]) Take(num uint) *Enumerator[T] {
	return &Enumerator[T]{iter: Take(e.iter, num)}
}

func (e *Enumerator[T]) GetEnumerator() *Enumerator[T] {
	return &Enumerator[T]{iter: e.iter}
}
