// This code was generated by a tool.
package enu
import "golang.org/x/exp/constraints"


type NumericEnumerable[T constraints.Integer | constraints.Float] struct {
	enumerator IEnumerator[T]
}

func NewNumeric[T constraints.Integer | constraints.Float](e IEnumerator[T]) *NumericEnumerable[T] {
	return &NumericEnumerable[T]{enumerator: e}
}

func (e *NumericEnumerable[T]) Each(iteratee func(T, int)) {
	each[T](e, func(item T, index int) bool {
		iteratee(item, index)
		return true
	})
}

func (e *NumericEnumerable[T]) ToSlice() []T {
	return ToSlice[T](e)
}

func (e *NumericEnumerable[T]) Count() int {
	return Count[T](e)
}

func (e *NumericEnumerable[T]) Filter(predicate func(T, int) bool) *NumericEnumerable[T] {
	return &NumericEnumerable[T]{
		enumerator: Filter[T](e, predicate),
	}
}

func (e *NumericEnumerable[T]) Nth(nth int) (T, bool) {
	return Nth[T](e, nth)
}

func (e *NumericEnumerable[T]) Find(predicate func(T, int) bool) (T, bool) {
	return Find[T](e, predicate)
}

func (e *NumericEnumerable[T]) First() (T, bool) {
	return First[T](e)
}

func (e *NumericEnumerable[T]) Last() (T, bool) {
	return Last[T](e)
}

func (e *NumericEnumerable[T]) Reverse() *NumericEnumerable[T] {
	return &NumericEnumerable[T]{enumerator: Reverse[T](e)}
}

func (e *NumericEnumerable[T]) SortBy(sorter func(i, j T) bool) *NumericEnumerable[T] {
	return &NumericEnumerable[T]{enumerator: SortBy[T](e, sorter)}
}

func (e *NumericEnumerable[T]) Reject(predicate func(T, int) bool) *NumericEnumerable[T] {
	return &NumericEnumerable[T]{enumerator: Reject[T](e, predicate)}
}

func (e *NumericEnumerable[T]) IsAll(predicate func(T) bool) bool {
	return IsAll[T](e, predicate)
}

func (e *NumericEnumerable[T]) IsAny(predicate func(T) bool) bool {
	return IsAny[T](e, predicate)
}

func (e *NumericEnumerable[T]) Take(num uint) *NumericEnumerable[T] {
	return &NumericEnumerable[T]{enumerator: Take[T](e, num)}
}

func (e *NumericEnumerable[T]) Result(out *[]T) *NumericEnumerable[T] {
	Result[T](e, out)

	return e
}

func (e *NumericEnumerable[T]) Err() error {
	if p, ok := e.enumerator.(ErrorProvider); ok {
		return p.Err()
	}
	return nil
}

func (e *NumericEnumerable[T]) GetEnumerator() IEnumerator[T] {
	return e.enumerator
}

func (e *NumericEnumerable[T]) Contains(item T) bool {
	return Contains[T](e, item)
}

func (e *NumericEnumerable[T]) IndexOf(item T) int {
	return IndexOf[T](e, item)
}

func (e *NumericEnumerable[T]) Max() T {
	return Max[T](e)
}

func (e *NumericEnumerable[T]) Min() T {
	return Min[T](e)
}

func (e *NumericEnumerable[T]) Sort() *NumericEnumerable[T] {
	return NewNumeric[T](Sort[T](e))
}

func (e *NumericEnumerable[T]) Sum() T {
	return Sum[T](e)
}

func (e *NumericEnumerable[T]) ToMap() map[int]T {
	return Reduce[T](e, func(agg map[int]T, item T, index int) map[int]T {
		agg[index] = item
		return agg
	}, map[int]T{})
}

func (e *NumericEnumerable[T]) Uniq() *NumericEnumerable[T] {
	return NewNumeric[T](Uniq[T](e))
}
